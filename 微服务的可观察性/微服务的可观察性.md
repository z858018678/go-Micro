# 微服务的可观察性

## 微服务运维

### MTTR

- 平均修复时间（多久修复）

### MTBF

- 平均无故障的时间（多长时间出问题）

### 服务巡检

- moringchecklis

	- 固定检查日志报表来查询错误

## 日志

### 日志级别 go(glog)

- info

	- 可以分级别，日志级别的可用性

- warning

	- 一般是不会修复的，会先修复error
	- go编程哲学，go所有警告都是错误，会直接报错
	- 养成好的习惯，把所有的warning都消除掉

- error

	- 处理error，就是让另外的去掉用这个error
	- 把error抛给调用者在顶部打日志
	- 处理日志产生降级，a逻辑失败走到b逻辑

		- 降级就是属于有损服务了

- fatal

	- 直接os.exit()推出

		- defer语句不会被执行
		- buf不会直接push
		- 临时文件不会被删除

	- 尽量不要用这个日志直接退出，尽量将所有的错误抛给调用者，让main函数直接推出

- debug(非常频繁的调用Debug日志接口的话会拉低性能，日志的开销很大)

	- 只有两者需要记录

		- 开发人员需要关注的信息
		- 普通的用户需要关注的信息

### 日志的实现

- 1、全局注入log对象
- 2、依赖对象

### 日志选型

- elk stack
- 日志系统特征

	- 收集

		- 能采集各个来源的日志数据

	- 传输

		- 稳定的把日志数据传输到中央系统

	- 存储

		- 存储日志数据

	- 分析

		- 可以支持UI分析

	- 警告

		- 提供错误报告

- 模型选编

	- app serve日志->本地->LOGstash->kafka->es

### 日志设计目标

- 格式规范

	- 日志输出统一用json
	- time日志产生时间
	- level日志级别
	- appid应用id
	- instaid 实例id

- 采集

	- logstash

		- 监听TCP网络上报

	- filebeat

		- 直接写入本地文件，采集本地文件

	- logagent

		- 物理部署
		- 直接读取本地文件

	- flume+kafka

		- logid进行区分

- 切分

	- 传输链路根据fulink来做

- 存储检索

	- es来存储
	- 检索kibana

- 容器日志采集

	- overlay2

		- 直接从物理机上查找对应日志文件

## 链路追踪

### 设计目标

- 无处不在的部署
- 持续的监控
- 低消耗
- 应用级的透明

- 延展性
- 低延迟


### Dapper

### 跟踪采样

- 固定采样
- 积极采样

	- 高qps增加

		- 减少采样率

	- 低qps

		- 增加采样率

- 二级采样
- 一级采样

### 性能优化

- 不必要的串行调用
- 缓存读放大
- 数据库写放大
- 服务接口聚合调用

